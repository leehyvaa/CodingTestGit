&는 포인터에서 nullptr에 값을 넣는다거나 type이 다른걸 마음대로 캐스팅하거나 하는 문제들을 
줄이기 위해 고안된것
STL을 매개변수로 넘길때는 항상 &를 사용한다 ex)
bool cmp2(vector<int>& v1, vector<int>& v2, int idx){
	return v1[idx] > v2[idx]};
위와같이 &로 매개변수를 생성했을땐 함수내에서 &가 없는 일반변수처럼 사용가능



//using으로 네임스페이스 선언을 해주는건 편리하지만
//두개의 네임스페이스 안에 같은 함수이름이나 클래스 등이 있을 경우
// 충돌이 나기 때문에 선언을 할 땐 주의해야함
//cout << hex << a <<endl hex 자리에 oct 나 dec 처럼 몇진수인지 바꿔줄 수 있음
//cout<<a 처럼 cout.put(a);도 가능
//\t 탭 \v 수직 탭 \b 백스페이스 \r 캐리지 리턴 \a 경보  \\백슬래시 \?물음표
//wchar_t 2바이트char   float 는 6이 유효숫자, double 은 15
//static_cast<long>(a); 일반 (형변환)보다는 static_cast 를 사용하는게 더 좋음




//cin.getline(문자열포인터,사이즈)는 c의 getchar를 대체할 수 있음
//스페이스바를 포함해 한 행을 받는다
//cin.get(문자열포인터,사이즈)는 원하는 크기만큼 문자열을 입력받지만 사이즈를
//초과할 경우 버퍼가 남아서 나중에 영향을 준다
//cin.clear()나 cin.ignore() 로 버퍼를 날려줘야함 다만 ignore도 지울 사이즈를
//정확하게 지정해 줘야 해서 사용하기 위험
//cin.ignore(numeric_limits<stramsize>::max(),'\n');
//string은 str1 += str2 같은 수식도 사용가능 연산자 오버로딩의 기능
//str.size()로 스트링의 길이를 받을 수 있다.

//getline(cin,str1); 로 스트링 객체를 입력받을 수 있다.
//문자열 앞에 L이나 TEXT를 붙여서 2바이트 와이드형으로 받거나 할 수 있다.
//enum에서 int형으로는 연산추가하여 바꿔 쓸 수 있지만 반대는 안된다.
//new 키워드와 delete 키워드
//int* pInt = new int[128]; , delete[] pInt; 식으로 사용
// if(pInt) delete pInt; 이렇게 사용해야 pInt가 이미 해제되었는데 다시 해제시도를 해서
// 에러가 발생하는걸 예방할 수 있음 배열로 선언했으면 delete[] pInt 이렇게 배열로 해제해야함
// delete 후에는 ***** if(pInt) pInt = nullptr; 도 해줘야 함 ******
// 
//_CrtSetBreakAlloc(151); 이 함수로 메모리릭 위치를 찾을 수 있음 151자리에 에러난 위치
////_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF || _CRTDBG_LEAK_CHECK_DF);
//	//_CrtDumpMemoryLeaks();메모리릭탐지 

//array는 array<int, 5> ai 이렇게 사용함
//드모르간의 공식 (no < 10 || no > 99);  와 !(no>=10 && no <=99 는 같은 공식이다



// i++같은 증감 연산자는 내장자료형에선 ++i와 차이가 없지만
//사용자 정의 자료형 (클래스) 에서는 접두어가 더 효율적이다.
//string은 str.compare()나 str=="문자열"로 비교가 가능하다.


//311p 패킷보안
// ==로 비교할 때 왼쪽에 상수를 둘 것, 실수로 =연산자를 썼을때를 대비가능
//cctype h파일로 isalpha(),isspace(),isdigit(),ispunct() 등등의 문자판단 기능이 있음
//goto문은 강력한 흐름제어문인데 코드흐름을 읽기가 어렵게 하니 반드시 필요할때만 사용 
//switch case 문은 한눈에 볼 수 있도록 케이스당 함수 하나로 간결하게 줄일것




	//매듭법(신발끈공식)
	//double ax, ay, bx, by, cx, cy;
	//cout << "세 점 입력 : ";
	//cin >> ax >> ay >> bx >> by >> cx >> cy;
	////ax bx cx ax
	////ay by cy ay

	//double first = ax * by + bx * cy + cx * ay;
	//double second = ay * bx + by * cx + cy * ax;

	//double res = abs(first - second) * 0.5;

	//cout << "삼각형의 면적 : " << res;







//명시적 특수화
//구조체는 일반적으로 대입등이 가능하지만 얕은복사나 깊은복사때 메모리를 공유하기 때문에
//명시적 특수화를 사용하게 됨




//클래스의 디폴트 접근제어는 private이다.
//구조체는 디폴트 접근제어가 public





//this 포인터는 같은종류의 클래스 객체 2개가 함수 내에서 비교우위등을
//통해 둘 중 하나의 객체만 반환할 때 유용하게 사용가능함
// 
//1.const Stock & topval (const Stock & s) const;
//2.const Student & Student (string name, string str2, int money)
//이런 이상한 방식의 함수선언이 있는데 두 객체에 접근하는 함수이다.
//1의 예시의 경우 한 객체에는 암시적으로 접근하고, 다른 한 객체에 명시적으로 접근한다.
//그리고 나서 두 객체 중의 하나에 대한 참조를 리턴하는 함수인데,
//괄호 안에 있는 const는 그 함수가 명시적으로 접근된 객체를 변경하지 않는다는 뜻이고,
//괄호 뒤에 있는 const는 그 함수가 암시적으로 접근된 객체를 변경하지 않는다는 뜻
//앞의 const Stock& 이나 const Student& 가 리턴형인듯? 
// 
//객체 배열을 선언과 동시에 초기화 할 때 배열 요소들을 각각 
//생성자 오버로드 방식을 다르게 하여 선언할 수 있다.
//p677 const 용법설명
//







//1. total = coding.Sum(flxing);
//2. total = coding.operator+(flxing);
//3. total = coding + flxing;
//위의 3가지 코드는 모드 같은 기능임
// 2번 코드는 3번코드를 풀어서 설명한것 
// +는 연산자 오버로딩이고
// =은 보통 연산자 오버로딩을 하면 따라오는 기능
// 다만 메모리를 건드릴땐 = 가 에러를 내기때문에 =도 오버로딩 해줘야함

//연산자 오버로딩은 연달아 가능함 t4=t1+t2+t3;
//이건 해석하면 t4 = t1.operator+(t2.operator+(t3)); 리턴이 클래스 객체라 가능

//연산자 오버로딩 가능한 목록들 c++ 기초플 722p

//프렌드 함수가 클래스 내부에 멤버로 있을 경우에는 매개변수를 하나만 넣어도 작동함
//암시적으로(?) 알아서 this포인터를 첫번째 매개변수로 넣어서 작동됨
//ex
//friend Time operator+(const Time& t)const; 는 멤버가 아닐 경우
//friend Time operator+(const Time& t , const Time& t2); 원래 이거임
//




//friend cVector3 operator*(double n, cVector3& vec);
//friend std::ostream& operator<<(std::ostream& os, const cVector3& v);//출력
//다른 객체에 있는 함수에 매개변수를 추가하고 싶을 때 사용함
//ostream 객체에 있는 함수에 매개변수를 ostream말고도 cVetor3를 사용하게 해달라 하는것 







//static 키워드는 함수 내에서 static 변수 선언시
//그 함수가 호출 후 종료되어도 static 변수는 값이 남아있음 따라서
//다음 호출시에 값이 유지됨

//클래스 내에서 public 멤버변수로 static 변수를 만들어 놨을 경우
//StringBad :: 변수이름 = 3 이런 식으로 메인함수에서 코드를 쓰면
//해당 클래스의 변수값을 프로그램 종료 전까지 영구히 바꿀 수 있음
//전역변수마냥 사용하고, 클래스 객체를 선언하지 않아도 사용 및 값지정 가능
//해당 객체가 몇개나 생성되었는지를 카운팅 할 때 사용할수도 있음






//생성자가 여러 개일 경우 모두 대괄호를 사용하든지 아니면 모두 대괄호
//없이 사용해야함 즉 방식을 통일해야한다.
//일반적인 복사생성자는 다음과 같아야 한다.
// String::string (const String & st)
// {
//	num_strings++;
//	len = st.len;
//  str = new char[len+1];
//  std::strcpy(str,st.str);
// }
//832,833p 얕은복사, 깊은복사 생성자
//
//836p 벡터의 레퍼런스를 매개변수로 넘길때 리턴이 객체인지 레퍼런스인지
//838p 객체리턴
//851p 객체 포인터










//class FlyingMonster : public Monster 상속 문법
//부모의 private 변수는 상속은 받지만 접근이 안됨 따라서 public get,set
//함수로 접근해서 바꿔야함
// 
//자식의 함수 내용엔 항상 자동적으로 부모의 디폴트 생성자가 실행되고있음
//오버로드중인 다른 생성자를 실행하고 싶으면 
//FlyingMonster::FlyingMonster(string str, bool bFlying)
//   : Monster(string str), isFlying(bFlying)
//       ㅡㅡ위와 같이 적어줌
//
// 907p 업캐스팅, 다운캐스팅 부모와 자식 사이의 관계
// 함수의 매개변수로 부모 객체를 받는 곳에 자식 객체를 넣어도 
// 암시적으로 변환되서 사용됨
// Fruit* pf1 = new Apple;
//Fruit* pf2 = new Banana;
//pf1->name();
//pf2->name();
// 
// 
// 상속처리가 되었을때 버츄얼 키워드를 생성자나 소멸자에 넣을 경우
// 부모 생성자 - 자식 생성자 - 몸체 - 자식 소멸자 - 부모 소멸자 순으로 진행됨
// 부모 쪽에서 virtual 키워드로 함수를 썼을 경우
// 자식이 그걸 덮어씌워서 사용할 수 있는 여지가 생김
// 생성자는 virtual 키워드 사용이 불가능함
//916p
//
// class FlyingMonster : private Monster
// 이렇게 상속을 할 경우 부모에서 상속된 모든 것들이 자식은 사용할 수 있지만
// 다른 곳에서는 접근을 못하게 private화 된다.
//
//순수 가상 함수 virtual void Attack() = 0; 이런식의 함수를 말함
//기능적으로는 존재하고 작성은 자식에서 알아서 하라는 뜻 
//이런 순수가상함수로만 구성된 클래스를 인터페이스라고 함
//
//상속할때 소멸자는 항상 virtual을 해줘야 함






/1012p 기초 클래스 객체에 접근하기, 프렌드에 접근하기
//상속보단 클래스 멤버에 객체를 넣는 포함관계(has)를 쓰는게 더 에러가 적음
//상속관계는 관계가 꼬일 수 있음
//
//protected 멤버를 public 상속 할 경우엔
//상속받은 자식이 그 멤버에 바로 접근해서 사용가능함 다만 분류는private처럼
//들어감 1020p
//
//protected상속은 private이랑 protected는 protected로 가고
//private은 private으로 감
//protected 상속을 하면 private랑 protected는 재 상속이 가능함
// 
//public 상속은 그대로 내려오고 
//private 멤버는 get함수로 접근해야함
//
//특수한 목적이 없으면 그냥 public 상속을 사용할것
//
//다중 상속시에 가상 상속을 사용하는 이유는
//다중 상속을 하면 부모클래스 즉 기본 클래스가 두개 이상이기 때문에
//다중 상속을 받은 파생 클래스(자식 클래스)의 객체를 생성할 때
//기본 클래스의 멤버들이 두개씩 선언이 되어버리는 문제가 발생한다
//따라서 두가지 부모 클래스를 선언 할 때
//class Singer : virtual public Worker
// class Waiter : virtual public Worker
//둘 다 이렇게 가상 클래스로 선언해주면 저 두개를 상속한 클래스가
//class SingingWaiter : public Singer, public Waiter
//위와 같이 선언 되었을 때 멤버를 두개씩 선언하지 않고 정상적으로 선언된다.
//
// 기본 클래스쪽에서 함수에 virtual 키워드를 붙이면 그 순간부터
// 가상함수 테이블이 생성이 되고 그 밑에 자식들에 중복되는 함수에는
// virtual을 붙여도 되고 안붙여도 된다. 
// 
// explicit 키워드를 붙이면 컴파일러가 암시적 형변환을 할 수 없게끔
// 제한한다. 명시적으로 형변환 해야함
//
//








//friend void Remote::set_chan(Tv & t, int c);
//위와 같이 프렌드를 클래스의 특정 함수에게만 줄 수 있다.
//이럴 경우 그 특정 함수만이 이 클래스의 멤버에게 접근이 가능하다

//try catch문
//try블록 안의 구문이 예외를 발생시키면 이 블록 뒤에 오는
// catch문이 그 예외를 처리한다.
// 
// 이 때  try블록안에서 예외를 부르는 방법은 throw 키워드를 쓴다.
// throw로 디버그 스트링 뿐만 아니라 클래스 객체등을 보낼 수 있다.
// 
// 
// catch문 안쪽에 아래와 같이 적어서 서버로 로그를 보냄
//create log file
//send log to server 
//
// 예외 클래스들의 상속 계층을 사용할 경우에, 가증 늦게 파생된
// 클래스의 예외가 가장 먼저 실행되고, 기초 클래스 예외가 가장
// 마지막으로 실행된다. 따라서 catch 블록의 순서를 잘 배치해야 함
//
// 클래스 멤버중 동적할당을 하는 멤버가 있으면 그 클래스는 
// 깊은복사를 하는 복사생성자를 명시적으로 반드시 생성해줘야 한다 
// 안할경우 얕은복사로 인해 문제가 생기게 되어있음
// 대입연산자나 복사 생성자도 위와 같은 이유로 생성해 줘야함
// 
// 
// 이니셜라이저를 써서 생성자를 만들 경우
// 복사생성자를 생성하지 않기 때문에 더 효율적이다.
//
// 파생 클래스는 자기 자신의 생성자를 필요로함
// 
// 멤버 초기자 리스트
// 파생 클래스의 생성자를 만들 땐 함수선언 끝에쪽에
// ::부모클래스 생성자(생성자오버로드 매개변수들 입력)
// 이렇게 사용자가 정의한 부모 생성자를 실행하면서 자식 생성자를
// 실행할 수 있다 멤버 초기자 리스트를 명시하지 않았을 경우
// 부모 클래스의 디폴트생성자를 실행한 후 자식생성자를 실행한다
// 
// - 파생 클래스 생성자의 요점
// 기초 클래스 객체가 먼저 생성
// 멤버 초기자 리스트를 사용하여 기초클래스 생성자를 실행 후
// 파생클래스 생성자를 실행한다.
// 
// 기초 클래스 포인터로 자식클래스 객체를 지시하거나 참조할 수 있다.
// 다만 그 포인터로 파생클래스 자체의 함수등은 실행할 수 없다.
// 위 포인터 기능으로 부모객체들과 자식 객체들을 한 배열로 묶을 수 있다
//
// 가상 소멸자가 필요한 이유
// 위와 같이 부모객체와 자식 객체들을 같이 사용할 때
// 부모 포인터로 둘을 묶어서 사용하는데 부모 포인터로 사용하고
// 객체를 삭제할 경우 부모 소멸자만 실행이 되는데 이것 때문에
// 가상 소멸자가 필요해진다 자식소멸자 없이 부모 객체 소멸자만 있을 경우
// 자식 객체 사용후 삭제할 때 상속받은 내용은 다 소멸자로 사라지지만
// 자식객체-부모객체를 한 나머지들이 소멸하지 않고 남아버린다
//
// 버츄얼함수는 컴파일 시점에 실행할 함수가 미리 정해지는 것이 아닌
// 프로그램 실행 도중에 가상함수 테이블에서 골라서 사용하기 때문에
// 조금 동작이 느린 감이 있다. 
// 
// 업캐스팅 - 파생클래스의 참조나 포인터를 기초 클래스의 참조나 포인터로
//   변환하는 것
// 다운캐스팅 - 업캐스팅과 반대로, 기초 클래스 포인터나 
//   참조를 파생클래스 포인터나 참조로 변환하는 것
//   다운캐스팅을 일반적으로 불가능 하지만 다이나믹캐스트 같은걸로
//   동작하게 할 순 있다.
// 
// 
// 버츄얼로 상속된 메서드를 재정의 하려면 오리지널 함수와 
// 매개변수나 반환형을 반드시 일치시켜야 한다
// 버츄얼로 상속받은 자식클래스에서 오버라이드를 쓰면
// 빨간줄이 뜨는지로 매개변수나 반환형이 혹시 바뀌었는지 체크할 수 있다
// 따라서 자식 클래스에선 오버라이드를 붙여서 쓰는걸 권장함
// 
// 프로텍티드 멤버들은
// 상속을 할 경우 자식클래스의 프라이빗 멤버처럼 취급이 된다
// 
// 
// 순수가상함수를 가지고 있는 클래스는 객체를 만 들 수 없고
// 추상화 기초 클래스는 반드시 순수가상함수를 하나 이상 가져야 한다
// 
//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
// 상속과 동적 메모리를 쓰는 함수의 관계
// **기초클래스가 new를 하던 말든 파생이 new를 썼냐가 중요하다
// 
//   파생 클래스가 new를 사용하지 않았을 때는
// 자식클래스의 
// 명시적 소멸자, 복사 생성자, 대입연산자를 정의할 필요가 없다
// 이유는 아래와 같다
// 1.파생 클래스의 디폴트 소멸자는 자신의 코드를 수행한 후에
// 기초 클래스의 파괴자를 항상 호출하기 때문에 문제가 없고
// 2. 복사 생성자의 경우 파생 클래스
// ~~~~~
// 하여튼 할 필요 없음
// 
//     파생 클래스가 new를 사용해 버렸을 경우
// 파생 클래스를 위한 명시적 소멸자, 복사 생성자, 대입 연산자를 
// 만들어 주어야 한다.
// 이때 소멸자는 그냥 만들어 주면 되는데
// 복사 생성자는 좀 까다롭다
// 파생클래스의 복사 생성자는 파생 클래스 내부의 데이터에만 접근할
// 수 있으므로, 파생 받은 기초 클래스의 멤버에 대한 복사를 처리하려면
// 부모 클래스의 복사 생성자를 호출해야 한다
//  - 무슨 말이냐면 복사할 때 기초클래스로부터 받은 내용중 private
//	 같은게 있으면 자식 클래스의 자력으로는 복사를 할 수가 없다
//   그래서 부모 클래스의 복사생성자를 가져와서 사용한다
// 대입연산자도 복사 생성자와 비슷하게 부모클래스의 대입연산을
// 사용한 후 자식클래스 자신의 값을 복사하는 식으로 진행한다.
// ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
//



//페어를 쓰는 두가지방법 
	 
	//1번
	pair<int, string> s (1, "서울");

	//2번 자료형 두개를 계속 써주기 귀찮으니까 타입정의해서 편하게 사용
	typedef pair<const int, string > Pair; 
	Pair a(1, "서울");


	//멀티맵은 페어를 같이 사용해줘야 함
	typedef multimap<int, string> Mapcode;
	Mapcode code;

	//멀티맵 객체에다 페어를 인서트
	code.insert(Pair(1, "서울"));
	code.insert(Pair(1, "인천"));
	code.insert(Pair(1, "부산"));
	//같은 키값에 여러 밸류를 넣을 수 있음

	Mapcode::iterator it2;

	for (it2 = code.begin(); it2 != code.end(); it2++)
	{
		(*it2).first; //자료값을 확인하는 방법
		//first는 키값을 의미, second는 밸류값을 의미
	}
	// 출력내용
	// 1 : 서울
	// 1 : 인천
	// 1 : 부산









//getline은 3번째 매개변수에 구분문자를 받아서 문자열에서 해당 문자가 나오면
//입력을 중지한다 즉 구분문자 전까지만 입력을 받는다
//이 때 구분문자는 버퍼에서 지워버린다 반대로 cin.get(input, Limit, 구분문자)
//get은 구분문자를 버퍼에 남겨둔다

//파일입출력시 커서 컨트롤 p1439, 파일입출력 예제 p1444

//class student :: string
//일때 
//&string student:함수
//








클래스 멤버는 프로텍티드도 쓰지 않는걸 권장
멤버를 프라이빗하고
그 멤버를 세팅하는 함수를 프로텍티드로 사용한다 이러면 디버깅이 편함



함수를 헤더에서 정의하면 인라인 취급이 되어서
함수 호출비용을 아낄 수 있다. 
자주 사용하고 짧은 함수는 인라인으로 사용하기에 적절함



클래스 멤버에서 벡터를 쓸 경우
그 벡터와 일반적인 벡터의 구성인덱스는 그 클래스의 소멸자가 자동으로 메모리를 정리한다.

다만 벡터에 요소가 포인터 타입이고 그 포인터가 다른주소에서 배열등을 가지고 있을 경우
이 배열의 요소들은 따로 메모리를 해제해야 한다.







유니온의 메모리 크기는 구성 멤버중
가장 큰 자료형의 메모리 크기로 정해진다
그리고 그 공간을 다른 멤버들이 공유해서 사용함



