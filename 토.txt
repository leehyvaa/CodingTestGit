유니티 계정
mayamind@inha.ac.kr
Inha@860hrd121

소스트리 토큰
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
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
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

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

게임잡에 마감일 적혀있는 공고가 회사가 급한 공고 - 진짜로 신입을 뽑는 회사
공고를 자주 업데이트하는 회사


스코프연산자 붙여야 -> 사용가능

리팩토링 하는 습관을 만들어라 그럼 실력이 많이 늘음
1.작동만 되게
2.다시 짜기

클래스로 오브젝트를 생성하는 과정을 인스턴시에이트 라 한다

행위를 하고있는 변수들을 is moving 등으로 이름을 적음
이벤트 트리거가 발동된 상태일때 On ~~로 이름을 사용


실존하는 무언가를 생각하고 여기서 객체를 뽑아낸 다음 조합하여 클래스로 지정한다 

vector : 힘과 방향
position : 스칼라(값(힘)만 가짐)

공격하는 주체쪽에 트리거를 넣는다

안쓰는 ui는 레이캐스트 타겟같은걸 꺼놓으면 메모리에 도움

Find With Tag 메모리상 사용을 권장하지 않음 그나마 with tag 사용

가능하면 오브젝트들은 켜놓고 필요없으면 끄는 방식으로 세팅

Project Setting에서 Physics에 가면
Layer Collision Matrix로 레이어끼리의 충돌을 컨트롤 할 수 있다.

{
	데이터 읽음
	wait for second
	데이터 업데이트
}
위와 같은 구조처럼 대기시간을 사이에 두고 데이터 로드와 업데이트가 떨어져 있으면
저 대기시간 동안 서버같은 곳에서 데이터를 받아갈 경우 문제가 생길 수 있기 때문에 위험한
코드이다.
따라서 아래와 같이 코드를 작성해야함
{
	데이터 읽음
	데이터 업데이트
	wait for second
}
or
{
	wait for second
	데이터 읽음
	데이터 업데이트
}
or
{
	데이터 읽음
	wait for second
	데이터 읽음
	데이터 업데이트
}

클라이언트와 서버 사이엔 이벤트 식으로 각각 데이터를 주고 받는것과
페이징 기법으로 시간텀을 두고 여러 데이터를 모아놨다가 한번에 주고받는 방식이 있는데
타격감을 위해선 예를 들어 이벤트식으로 클라이언트 내에서 유저한테 먼저 보이는 몬스터 hp 수치와
서버랑 주고받는 hp 변수를 따로 만들어서 돌려야함

캐릭터가 타격을 할땐 타격 코루틴에서 타격임팩트 타이밍에 맞춰서 콜라이더를 껏다 켜줘야함
안그럴경우 공격 시작동작때 몬스터와 붙어있다면 칼을 휘두르기도 전에 타격이 들어갈 수 있음



빌드 추가사항
프로젝트세팅 - 플레이어 -스플래시로 제작자 이름등을 시작할때 유니티 로고와 함께 보이게 할 수 있음


BELBIN's의 Team-Role Balance


개발문서 작성법
//장르,내용, 순서도, 구성요소, 상호작용, 
//함수단위(인자가 뭔지 리턴이 뭔지, 함수기능설명,등등)
//컴퍼넌트가 어떤 작용을 하는지, 다이어그램, 개발 일정


gpt 질문순서
등장배경 장단점
알기쉽게 설명 - 더 쉽게 설명 - 식당등 비유 
-자세하게 설명 - 핵심 기능 설명



싱글톤은 최대한 지양하지만 쓸수밖에 없는 구조기에 반드시 필요할때만 사용
델리게이트는
델리게이트는 주로 콜백 메커니즘, 이벤트 처리 및 메서드를 객체처럼 전달하는 상황 등에서 사용된다



기획서를 보면 
오브젝트와 UI를 다 구분해서 먼저 뽑아낼것

오브젝트가 단일인지 다중인지를 구분하여 배열로 선언을 해야할지 정리


코루틴을 사용하여 인간형이 아닌 엔티티의 애니메이션을 출력하는 것은 추천하지 않는다.
더 적은 코드로 더 나은 결과를 얻을 수 있는 DOTween 같은 Tween 엔진을 사용하길 권한다.


ab테스트




유니티와 언리얼의 차이
유니티 - 게임개발의 민주화라는 모토로 진입장벽을 낮추는데 목적이 있음
	유니티는 게임오브젝트 기반으로
	유니티는 프리팹을 만들어서 사용하고
	머테리얼 하나당 쉐이더 하나씩 사용(이 랜더링 파이프라인의 이유 때문에 고퀄리티를 내려면
	유니티는 성능이 많이 떨어져서 고퀄리티를 안쓰는것)

언리얼 - FPS를 기반으로 만들어진 엔진이라 장르가 기본적으로는 어느정도 한정되어있고
	고퀄리티를 추구함
	언리얼은 엑터를 기반으로
	언리얼은 블루프린트클래스를 만들어서 사용
	머테리얼 하나당 쉐이더가 아니라 조합해서(?) 사용함(고퀄리티에 용이)





다이아몬드상속 문제
위에위 클래스를 참조할때 어디서 양쪽중에서 상속되어 내려온건지 알 수 없음


면접 절차
1. 1분 자기소개(직무역량을 키우기 위해 어떤 성장과정을 겪었는지)
2. 자기소개 한 내용을 꼬리물기


C vs C++
C는 절차지향적이고 메모리를 적게 쓰고 속도가 빠름
단점으로는 유지보수가 힘들다.
C는 절차지향이라 함수중심으로 움직이고 C++은 객체지향이라 객체(붕어빵,instance) 중심으로 움직임

C++은 
C의 장점을 살리려 했기에 완전 객체지향은 아니고 절차지향적인 부분이 남아있음
C에 비해 메모리는 포기했지만
C의 속도를 최대한 살렸고
객체지향을 도입해 유지보수와 확장성이 좋아짐
C++을 사용할땐 객체지향과 절차지향 둘다 가능하기 때문에 객체지향적으로 짜도록 노력해야함
유닉스 기반으로 만들어져서 여러 운영체제에서 다 작동함(리눅스, 맥 등)
C++을 사용하다 메모리릭이 나면 프로그램이 종료해도 해당 메모리가 여전히사용중임(누수)
C++은 빌드하면 로그파일에 어떤 메모리 주소를 사용했는지 전부 남아있음
그 로그에서 메모리주소를 찾으면 누수난 메모리를 찾을 수 있음
구조체와 클래스가 유사함

C#은
굉장히 객체지향적인 언어
C를 기반으로 자바를 참고해 만들어서 자바와 유사함
닷넷에다 비주얼베이직을 얹어서 만듬
간단한 툴이나 어플을 만들때 굉장히 유용함
윈도우 기반인데 다른 운영체제에서 사용 가능한 이유는 닷넷을 쪼개놔서 모노(?)버전을 업데이트 하면
다른 운영체제에서도 사용할 수 있음
c#은 컴파일하면 기계어로 바로 바뀌는게 아니라 CLR로 바뀌어서 사용된다.
구조체는 값형식이고 클래스는 참조형식


구조체와 클래스 차이
C++에서는 구조체가 상속도 가능해서 클래스와 거의 유사함


C#에서 클래스는 참조형식이라 클래스 인스턴스는 모두 메모리주소를 통해 참조된다.
	구조체의 인스턴스는 실제 데이터 값을 포함하고 변수에 할당될 때 복사된다.
C#에서 구조체는 무조건 값형식이라 C# 내에 구조체에는 string같은 참조형식은 안쓰는게 좋긴 함
값형식의 데이터 묶음등을 관리할때 유용하다.
c#의 구조체는 값형식을 가지고 있어서 vector등을 쓸때 new vector 식으로 쓰는데
값 형식이기 때문에 스택메모리에 들어가서 따로 관리할 필요가 없다.(가비지 컬렉터에 먹이가 아님)
클래스는 hip메모리에 저장



캡슐화의 장점과 사용이유
캡슐 단위로 사용하기 때문에 캡슐 안에 내용을 몰라도 상호작용을 하고
재사용성과 다른곳에서 가져다 쓰기가 편함
캡슐화 되어 캡슐안에는 접근이 제한되어 다른곳에서 함부로 접근할 수가 없어서 실수할 여지가 줄어듬

오버로드 더 적재하다
오버라이드 위에 얹어타다 


손코딩으로 자료구조가 나왔을땐
PUSH,POP,SEARCH등의 함수기능들부터 위에 선언하고 그 뒤에 정의를 하나씩 채울것


비트연산에서 xor 연산 (^) 은 교환법칙이 가능하여
같은 요소가 두개씩 있는 배열에서 하나만 짝이 없을때 O(n)으로 찾을 수 있다.
공간은 O(1)


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
			유니티 최적화의 방법

아래 DrawCall 줄이기 참고

프로파일링
	유니티의 프로파일러를 사용하여 성능 병목 지점을 정확히 식별한다.

오브젝트 풀링

동적 해상도 스케일링
현재 성능에 따라 게임의 해상도를 동적으로 스케일링하는 기술. 이를 통해
일관된 프레임 속도를 유지하고 저사양 장치에서 성능을 개선할 수 있다.

스크립터블 오브젝트
스크립트 간에 공유할 수 있는 재사용 가능한 데이터 오브젝트를 생성하는 데 사용할 수
있는 기능이다 이를 통해 메모리 할당에 따른 오버헤드를 줄이고 성능개선이 가능

셰이더 최적화
셰이더에서 수행되는 계산 횟수 줄이기, 텍스처 샘플링 최적화, 사용 명령어 수 최소화 등

불필요한 Update 호출을 피하고, 계산 집약적인 작업은 코루틴이나 비동기 처리를 통해 분산

네트워크 게임의 경우 데이터 전송량을 최소화하고, 메시지 패킹과 압축을 고려한다

고비용 함수호출을 줄인다.
	-ex Update 내에서 GetComponent 또는 Find
	-가능한한 Update 대신 FixedUpdate 또는 LateUpdate를 사용

Object 클래스의 서브클래스들이 Update에서 null체크 하는걸 지양할것
객체 초기화 시에 한번만 체크하는 방식

다차원 배열보다는 가변배열을 반복하는것이 더 효율적

파티클 시스템은 최소 3500바이트 이상을 소모, 메모리 소모는 파티클 시스템에 활성화 된 
모듈의 수에 따라 늘어난다. 이 메모리는 파티클 시스템이 비활성화 된 경우에는 해제되지
않고, 파티클 시스템이 파괴되었을때만 해제된다.

C# 델리게이트는 한 번 콜백이 추가 또는 제거될 때마다 해당 콜백 리스트 전체를 깊게
복사한다. Update처럼 프레임당 구독,구독취소 등이 있으면 성능이 크게 나빠진다

Update 내에서 함수 호출을 최대한 줄여야 한다. 특히 빌트인(기본내장) 함수들
프로퍼티 등을 사용하는것도 get,set함수를 쓰는거라 Update안에서는 오버헤드가 있음
단순한 데이터형이고 고정값이면 const를 사용할것 const값은 컴파일시 인라인되어서 
연산을 사용하지 않음 다만 간단한 데이터 타입에만 사용할것
const가 적절하지 않으면 static readonly 변수를 대신 사용하는것도 고려 


스케일 커브 애니메이션은 이동,회전보다 많은 비용이 들어간다.
애니메이션 레이어 가중치가 0이면 유니티에서 건너뛴다. 사용안할때는 가중치를 0으로할것
휴머노이드 애니메이션을 임포트 하는경우 아바타 마스크를 사용하여 필요하지 않은 
IK 골격 또는 손가락 애니메이션을 제거하고 사용한다

C#에서 모든 문자열은 변하지 않는다.
문자열을 조작하면 전체 문자열이 새로 할당됨 이것은 비용이 비싸며 반복적인 문자열 연결은
크기가 큰 문자열, 큰 데이터 세트 또는 빠르게 반복하는 루프에서 수행될 때 문제가 발생한다.
루프나 매 프레임에서 연결되어야 할 경우 StringBuilder를 사용한다.
StringBuilder 인스턴스는 불필요한 메모리 할당을 좀 더 최소화하기 위해 재사용된다.

문자열 비교는 서수 문자열 비교 방식으로 바꾸는게좋은데 String.Equials의 마지막 인수로
StringComparison.Ordinal을 작성하기만 하면 된다.
ex) myString.Equals(ohterString,StringComparison.Ordinal);
이것도 마냥 좋지는 직접 문자열 비교함수를 만들어 쓰면 속도가 더 빠르다.

텍스트 파싱은 로딩 시간에 발생하는 가장 무거운 작업 중 하나다.
텍스트 구문 분석의 부하를 피하는 가장 좋은 방법은, 런타임 시점에 텍스트 구문 분석을
완전히 제거하는 방법이다. 일반적으로 이는, 일종의 빌드 단계를 통해 텍스트 데이터를 
바이너리 포맷으로 베이킹 한다는 것을 의미한다.
데이터를 ScriptableObject파생 클래스 계층 구조로 이동시킨 후, 에셋 번들을 통해
데이터를 배포한다. 다만 이 방법은 동적으로 생성되어야 할 필요가 없는 데이터에 적합하다.
다른 방법으로는 분할하여 필요한 부분만 로드하는것과 멀티스레드를 사용하는 방법이 있다.

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
드로우콜

CPU가 GPU에게 그려달라 요청하는것
GPU가 과부화되면 CPU가 대기상태로 들어감 따라서 드로우콜을 줄여야함

GPU는 단순계산(행렬계산)을 잘함
인공지능도 다 행렬연산으로 이루어짐
이동,회전,스케일 srt순서로 하는게 좋음 3가지 다 4by4 행렬계산으로 이루어짐

드로우 콜의 과정
1.렌더링 명령 준비 
- CPU는 그려질 각 객체의 정보(모델,텍스처,쉐이더)와 어떻게 그려야 할지에 대한 명령을 준비한다.
2.GPU로 명령 전송
3.GPU에서 명령 실행

간혹 드로우콜보다 드로우콜에 대한 준비가 더 많은 리소스를 소모하기도 함
드로우 콜을 준비하려면 CPU는 리소스를 설정하고 GPU에 대한 내부 설정을 변경한다.
이러한 설정을 렌더상태라고 부르는데 다른 머티리얼로 전환하는것과 렌더상태를 변경하는
것은 그래픽스 API가 수행하는 작업 중 리소스 소모가 가장 큰 작업이다.

렌더 상태 변경을 최적화하는법은 렌더 상태 변경 수를 줄이는것
1.드로우 콜 전체 수를 줄이기
2.드로우 콜을 렌더 상태 변경 수를 줄이는 방식으로 구성 그래픽스 API가 동일한 렌더 상태를
사용하여 다수의 드로우콜을 수행하는 경우 드로우콜을 그룹화하여 렌더 상태 변경 수만큼
작업을 수행하지 않아도 된다.

드로우콜을 줄이는법
1.배치(Batching)사용
-스태틱 배칭(정적인 객체에 활용)
변하지 않는 객체들을 그룹화하여 하나의 대형 메시로 병합한다. 이는 정적인 환경에서 효과적
-다이나믹 배칭(동적인 객체에 활용)
유니티와 같은 엔진에서는 비슷한 렌더링 설정을 가진 작은 메시들을 자동으로 배치하여
드로우 콜을 줄인다. 다만 이 기능은 메시 크기나 복잡도에 제한이 있을 수 있다.

2.GPU 인스턴싱
-비슷한 객체를 여러 번 그릴 때,각각을 별개의 드로우 콜로 처리하는 대신 하나의 드로우콜로
그룹화 할 수 있다. 이 방법은 나무, 잔디, 장식 요소와 같이 반복적으로 등장하는 요소에 효과적

3.맵핑 최적화(Atlas/Texture Packing)
-여러 텍스처를 하나의 큰 텍스처 아틀라스로 결합한다. 이러면 여러 객체가 동일한
텍스처 아틀라스를 공유할 수 있으며, 이는 텍스처를 바꿔가며 그리는 드로우 콜의 수를
줄일 수 있다.

4.LOD(Level of Detail) 사용
-카메라로부터 멀리 떨어진 객체는 더 적은 디테일을 가진 모델로 렌더링한다.

5.불필요한 렌더링 제거
-Frustum Culling
카메라의 시야 밖에 있는 객체는 렌더링하지 않는다.
-Occlision Culling
다른 객체에 가려져 보이지 않는 객체는 렌더링하지 않는다.

6.쉐이더와 머티리얼 최적화
-가능한 한 적은 수의 쉐이더와 머티리얼을 사용한다. 다양한 객체가 동일한
쉐이더나 머티리얼을 공유할 수 있으면 이는 드로우 콜의 수를 줄이는데 도움이 된다.

7.매쉬 병합 (Mesh.CombineMeshes 함수)
-여러 개의 작은 메쉬가 아닌 하나의 큰 메쉬를 사용해 객체를 렌더링한다.
이는 특히 동적이지 않는 환경에 유용하다.

8.스테이트 변경 최소화
렌더링 상태 변경(ex:셰이더 변경,텍스처 바인딩 변경)은 드로우 콜에 앞서 수행될 필요가
있다. 상태 변경을 최소화하고 가능한 한 많은 렌더링 작업을 같은 상태에서 수행함으로써
드로우 콜을 줄일 수 있다.

9.SRP 배처
프로젝트에서 스크립터블 렌더 파이프라인(SRP)을 사용하는 경우 SRP 배처를 사용하여
Unity가 동일한 셰이더 배리언트를 사용하는 머티리얼에 대한 드로우 콜을 준비하고
디스패치하는 데 필요한 CPU 시간을 줄인다.

유니티가 사용하는 순서는
SRP 배처와 정적 배칭 -> GPU 인스턴싱 -> 동적 배칭 순이다.


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
Virtual Function(가상함수)

파생된 클래스에서 재정의할 수 있는 멤버함수
파생된 클래스에서 변경하거나 재정의 될 수 있기 때문에 가상이라고 한다.

가상 함수 테이블
가상 함수 구현에 대한 포인터를 저장하는 데 사용되는 데이터 구조

클래스에 가상 함수가 하나라도 있으면 컴파일러는 해당 클래스의 각 인스턴스에
가상 함수 테이블에 대한 포인터를 추가한다.

객체에서 가상 함수가 호출되면 프로그램은 가상 함수 테이블(vtable)에서 해당 객체의
함수 주소를 찾아 해당 주소로 이동하여 함수를 실행한다.

동적바인딩
가상 함수의 호출은 실행 시간에 결정된다. 즉 컴파일 시간이 아닌 프로그램이 실행되는동안
어떤 함수가 호출될지 결정함


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
랜더링파이프라인

렌더링 파이프라인9단계
 - 3D이미지를 2D 래스터 이미지로 보이게 하는 과정
로컬 스페이스 - 3D모델을 만들어서 로컬 좌표계에 띄운다(CPU담당)
월드 스페이스 - 구축한 3D오브젝트(모델)을 월드좌표계로 옮겨 하나의 장면을 구성(CPU담당)
뷰 스페이스 - 월드 좌표계로 변환된 좌표계를 카메라 기준 좌표계로 변환
	(카메라 위치가 원점이 되고 카메라가 보는 방향이 z축이 되도록 관찰점도 회전시킨다.)
백 스페이스 컬링 - 카메라 기준 뒷 부분을 잘라내서 최적화
라이트 - 조명 처리
클리핑 - 뷰 포트에 안보이는 것들을 깎아내고, 쪼개기
투영 - 3D물체를 투영시킨다 
	(3D물체를 2D평면에 표현하기 위해 변환연산, 
		원근투영을 주로 사용,카메라 기준으로 멀리 있으면 작게 나타냄)
뷰 포트 - 화면 크기로 맞추기
래스터 라이즈 - 픽셀단위로 점을 어떻게 찍어야 할지





ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
				디자인패턴에 대해
상태,전략,데코 포폴에 많이씀

싱글톤 굳이 구현했다고 기술문서에 쓰지말것
이벤트버스는 프로토타입정도에만 쓸것

방문자패턴은 구현이 어려움 겉핥기 하고 구현했다고 하지 말것(제대로 구현하면 효과가 강함)
어댑터는 싱글톤만큼 자주 사용함


디자인패턴 사용할땐 UML(클래스다이어그램, 시퀀스다이어그램) 을 상세히 구현하고 시작할것
방법은
1. UML 설계도 만들기
2. 설계도대로 구현하기
3. 설계도 수정
4. 반복



디자인패턴 사용하지 않고 일단 구현 후 리팩토링하는 방법
1. 일단 구현(동작되게)
2. UML로 만들기 -> 난잡해
3. 합칠거 합치고, 분리하고, 각 역할 명확하게 <- 리팩토링 *** (중요, 실력이 많이 늘음) ***
4. 도입하고자 하는 패턴을 UML로 정리
5. 구현






ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ


				전략패턴

전략패턴과 상태패턴의 차이

런타임에 동작을 선택하고 객체에 적용하길 원한다면 전략 패턴을 사용한다
객체의 내부 상태가 변경될 때 동작을 변경하고자 한다면 상태패턴을 사용한다

헷갈리기 때문에 해석할때도 만들때도 구현 의도를 판단할것


전략패턴을 사용해야 할 때
1. 동일한 동작이 다양하게 변형되는 엔티티가 있으며 개별 클래스에서 캡슐화하고 싶다.
2. 런타임에 현재 내부 상태를 고려할 필요 없이 특정 동작의 변형을 엔티티에 할당하고 싶다.
	(run이라는 동작에 옆으로뛰기 웃기게 뛰기 등 변형동작을 바꿔끼우며 사용하려 할 때)
3. 런타임에 정의된 선택 기준에 따라 특정 작업을 수행할 수 있또록 엔티티에 행동을 적용해야 한다.


카메라에 유용하다(뒤에서 따라다니기, 위에서 한번 훑기, 흔들리기 등)







ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ


				방문자 패턴

파워업 : 클라이언트가 가진 것 또는 그외의 것에 영향을 미친다.
달리다가 길에 떨어진 아이템에 닿으면, 갑자기 특정 능력이 향상

CLIENT -> 바이크 : BikeController
	Accept(Visitor)
	ELEMENT 리스트
	객체구조

IVISITOR : 방문자
	->구체화된 것 : 파워업
	->실제 각 요소들이 사용할 수 있게 데이터들을 가공 하여줌
	->알고리즘
	

IELEMENT : 조공 & 클라이언트가 필요한 것
	->구체화된 요소 : 엔진,쉴드,무기



언제 사용하나
-기능을 따로 클래스로 구현하는 것이니 데이터 구조는 변경이 없고 기능이 자주 변경되는
경우에 사용한다.







구현순서

111 비지터 껍질



마지막 바이크컨트롤
117 클라이언트 비지터(게임센터)
테스트버튼
픽업
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

				중개자 패턴

GameCenter 밑에다 Player,Enemy,Bullet 등의 여러 객체들이 들어있고
게임 진행을 GameCenter가 관제하는 패턴
Player 객체가 다른 객체와 뭔가를 하고 싶을때 Enemy를 직접 받아서 연결하지 않고
GameCenter를 통해서 상호작용을 하는것을 의미한다.
Player와 Enemy는 서로 절대 모르도록 구성하는것을 습관화 하는게 학습에 도움이 된다.
Player가 뭔가와 충돌체크를 해도 그 안에서 로직을 처리하지 않고
GameCenter한테 충돌했다는 콜백혹은 메세지를 보내서 그걸로 다른 객체가
처리하도록 처리

ex 플레이어가 총알을 쏠때 총알에 오너 변수가 있다 하면 
오너변수에는 플레이어 객체가 들어가는게 아니라 아군태그,적군태그 등으로 넣는게 맞다


오브젝트를 만들땐 ID값을 가지도록 하면 좋음(특히 배열같은것들)
객체를 최대한 최대한 나누고 확장성을 신경쓸것


Delegate를 사용해 볼것
싱글톤 탬플릿 만들어놓을것
Dictianary는 쓰지 말것


오브젝트풀 매니저(싱글톤으로 상속받을것) 

리스트로 오브젝트를 관리한다. 오브젝트 갯수를 늘리려면 리스트 인덱스를 늘리면 된다. 
 이 때 각 오브젝트는 ID 값을 가진다.
그리고 
큐로 ID 를 관리한다
큐 두개를 만들어서 대기 큐, 출장 나간 큐 를 두개 관리
스폰함수랑 반환함수를 만들어야함
스폰할때 큐에 남은게 있는지 확인하고 없으면 리스트 한계치를 더 늘림
스폰했을때는 오브젝트를 리턴해주는게 좋다.
반환할때는 ID를 리턴해준다.
초기 리스트에서 생성할때 오브젝트는 자신의 인덱스 번호를 ID값으로 가지고 있으면 매우 편하다.

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
퍼사드 패턴

퍼사드 패턴과 옵저버 패턴과의 차이

옵저버패턴은 객체가 객체를 알게끔 하는게 목표지만
퍼사드 패턴은 개발자에게 구조를 쉽게 볼 수 있고 내부구조를 알 필요가 없을 경우 코드를 숨기는게 목표다

만드는 순서는 메인 틀을 만들고 메인의 서브시스템들을 추가해서 만든다


어댑터패턴과 퍼사드패턴은 포폴에서 사용해 보면 좋음
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
추상팩토리 패턴

스테이지등을 만들 때 스테이지의 구성 요소 여러가지를 입력하면 해당하는 구성요소들을
조합한 스테이지를 만들어 주는 식으로 사용한다

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
딕셔너리 단점
인스펙터창에 생성이 안되고








ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
노말벡터 노말라이즈 내적 외적 법선벡터 조사

벡터
-수학개념으로 크기와 방향을 가지는 물리량을 의미한다.

내적
-임의의 벡터의 특정 방향을 가진 성분의 크기를 알아내는데 유용하다.
(두 벡터의 사이각을 알아내는데 유용하다)
-내적은 스칼라곱 또는 dot product라고도 하며, 두 벡터의 크기와 두 벡터 사이의
각의 코사인 값을 곱한것으로 정의한다(결과는 스칼라양이 나옴)
-수식으로 적으면 

외적
-면 벡터의 표현, 토크, 각속도 등을 구할때 필요하다.
외적은 두 벡터에 수직인 벡터를 구한다던지, 한 평면의 법선벡터(수직인벡터)를
구할 때 유용하다.
-외적은 벡터곱 또는 cross product라고 말하며, 두 벡터의 크기와 두 벡터 사이의
각의 사인값 그리고 수직인 벡터의 곱으로 정의한다(결과는 벡터값이 나옴)

벡터 노멀라이즈(정규화)
-해당 벡터의 방향은 유지한채 크기가 1인  단위 벡터로 만드는 과정이다.
이런 단위벡터를 사용하는 이유는 두개이상의 벡터를 연산할 때 좀 더
쉽고 단순하게 다룰 수 있기 때문이다.


노멀 벡터(즉 평면에 수직인 벡터), 혹은 법선 벡터
메시 생성 중에 자주 필요하며 경로 추적 및 다른 상황에서도 유용하다. 
삼각형p0p1p2의 면 법선을 구하려면 삼각형의 두 변에 놓인 벡터를 구한 후,
외적을 하면 구할 수 있음

미분이 가능한 표면의 경우 미적분 기법들을 이용해서 표면의 점의 법선을 구할 수
있음. 일반적으로 다각형 메시는 미분이 가능하지 않다. 다각형 메시에 대해서는
정점 법선 평균을 이용한 기법이 흔히 쓰인다. 임의의 정점v의 정점 법선 n을 구할
때, 정점 v를 공유하는 메시의 모든 다각형의 면 법선의 평균으로 근사한다.

dbwoaud26


셰이더
유니티에서 크게 3가지 카테고리로 나뉨
1.그래픽 파이프라인의 일부인 셰이더가 가장 자주 사용되는 타입이다. 화면의
픽셀 컬러를 결정하는 계산을 수행합니다.
2.컴퓨트 셰이더는 일반 그래픽스 파이프라인 외부,GPU에서 계산을 수행합니다.
3.광선 추적 셰이더는 광선 추적과 관련된 계산을 수행합니다.
유니티에서의 특징은 메터리얼 하나당 셰이더 하나가 붙는다.

렌더링파이프라인
-3차원 컴퓨터 그래픽스에서 3차원 이미지를 2차원 래스터 이미지로 표현을
하기 위한 단계적인 방법을 말한다. 
OpenGL과 Direct3D가 두 개의 3차원 그래픽 표준으로, 매우 비슷한
그래픽 파이프라인을 기술하고 있다.


래스터
래스터란 컴퓨터에서 화상정보를
표현하는 한 가지 방법으로 이미지를 2차원 배열 형태의 픽셀로 구성하고
이 점들의 모습을 조합,일정한 간격의 픽셀들로 하나의 화상 정보를 표현하는
것을 말한다. 즉 한 줄에서 연속된 픽셀들의 집합을 래스터라고 한다. 

DIrect3D
마이크로소프트의 DirectX API에서 3차원 그래픽스 연산과 출력을 담당하는
부분이다. 마이크로소프트의 윈도우 운영 체제에서만 작동하며,
엑스박스와 엑스박스 360 게임 콘솔의 그래픽 API로 사용되고 있다.

OpenGL
오픈 그래픽 라이브러리의 약자고, 실리콘 그래픽스사에서 만든 2차원 및
3차원 그래픽스 표준 API규격으로, 프로그래밍 언어 간 플랫폼 간의 교차
응용 프로그래밍을 지원한다. 이 API는 약 250개 가량의 함수 호출을 이용하여
단순한 기하도형에서부터 복잡한 삼차원장면을 생성할 수 있다.
현재 CAD,가상현실,정보시각화,비행 시뮬레이션 등의 분야에서 활용됨

Bolt
코딩 없이 노드 기반으로 작성 가능한 비주얼 스크립팅 툴
-코딩으로 인한 개발의 진입 장벽을 조금은 낮춰주고 비 프로그래머가 작업할 때
본인이 생각한 로직이 맞는지를 간단히 확인하거나 빠르게 프로토 타이핑을
내야 할 경우 사용하기 적절하다고 함.

albedo
반사율 또는 알베도는 물체가 빛을 받았을 때 반사하는 정도를 나타내는 단위이다.
반사율은 입사되는 전자기파에 대한 반사량으로 계산되며, 일반적으로 0%~100%
로 표현된다.


노멀맵
RGB 텍스처로, 여기서 각 픽셀은 표면이 향하고 있는 것처럼 보여야 하는 방향의
차이를 수정되지 않은 표면 노멀에 대해 상대적으로 나타낸다. 이 텍스처는
벡터가 RGB값에 저장되는 방법 때문에 푸른 보라빛을 띠는 경향이 있음
실제로 돌출되지 않고, 이름의 Normal은 노멀벡터를 칭하는 것
x,y,z공간상의 방향에 대한 정보를 RGB값을 이용해 가지고 있다.


높이맵
각 픽셀이 표면에서 점이 위로 올라온 것처럼 보여야 하는 정도를 나타내는 단순한
흑백 텍스처. 픽셀 컬러가 흰색에 가까울수록 해당 영역이 더 높이 올라온 것처럼
보인다.

범프매핑
렌더링될 물체의 픽셀마다 표면 법선을 흔들어 높낮이가 있어 보이게 하는
컴퓨터 그래픽 기술 중 하나이다. 그 결과는 실제 물체의 표면과 매우 비슷해 보인다.
범프 매핑으로 주로 쓰이는 기술에는 법선 매핑, 시차 매핑이 있다.

오클루전 컬링
오클루전 컬링은 다른 오브젝트에 가려(오클루전된) 카메라에 보이지 않는 오브젝트의
렌더링을 비활성화하는 기능이다. 절두체 컬링보다 더 효율적인듯

절두체 컬링
카메라 뷰 각도안에 있는 오브젝트만 렌더링 한다. 자동적으로 언제나 일어남

보조맵(디테일 맵) 및 디테일 마스크
보조맵을 사용하면 위에 나열된 메인 텍스처 위에 두 번째 텍스처 집합을 오버레이
할 수 있음. 두번쨰 알베도 컬러 맵이나 노멀 맵을 적용가능, 일반적으로
두 번째 맵은 메인맵에 비해 작은 스케일로 반복적으로 세부적으로 매핑됨
이는 머티리얼을 가까이서 볼때랑 멀리서 볼때를 디테일을 나눠서 메모리를 절약하기
위함






